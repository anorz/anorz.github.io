<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[mysql 四种事务隔离级别]]></title>
      <url>/2018/03/18/mysql-transaction-isolation/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> mysql </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq queue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[消息队列 RabbitMQ -- 介绍]]></title>
      <url>/2018/01/03/mq-rabbitmq-introduce/</url>
      <content type="html"><![CDATA[<p><a href="https://www.rabbitmq.org" target="_blank" rel="noopener">RabbitMQ</a> 是除了 Qpid 之外， 唯一实现了AMQP（高级消息协议：Advanced Message Queue Protocol）标准的代理服务器。<br>虽然AMQP像邮箱那样为离线消费者存储消息，但是这些根据标签路由的消息更为灵活。同时和邮件不同的是，这些消息没有固定的结构，甚至于可以直接存储二进制数据。不同于IM协议，AMQP隐去了消息的发送方和接受方。AMQP也没有“存在”这个概念。<br><br></p>
<h6 id="生产者-Producer-和-消费者-Consumer"><a href="#生产者-Producer-和-消费者-Consumer" class="headerlink" title="生产者(Producer) 和 消费者(Consumer)"></a>生产者(Producer) 和 消费者(Consumer)</h6><p>生产者创建消息(消息包含两部分: 有效载荷[payload] 和 标签[label])，然后发布(Publish) 到代理服务器(RabbitMQ)</p>
<p>消费者连接到代理服务器，并订阅到队列上。当消费者接受到消息时，它只得到了消息的一部分：有效载荷。在消息路由过程中，消息的标签并没有随有效载荷一同传递。<br><b>如果需要明确知道谁生产的AMQP消息的话，就要看生产者是否把消息方信息放入有效载荷中。</b></p>
<h6 id="AMQP栈"><a href="#AMQP栈" class="headerlink" title="AMQP栈"></a>AMQP栈</h6><p><img src="https://www.rabbitmq.com/img/tutorials/intro/hello-world-example-routing.png"><br>AMQP消息路由必须有三个部分： 交换器、队列、绑定。<br><b>生产者把消息发布到交换器上；消息最终到达队列，并被消费者解释；绑定决定了消息如何从路由器 路由到特定队列。</b></p>
<h6 id="生产者创建消息"><a href="#生产者创建消息" class="headerlink" title="生产者创建消息"></a>生产者创建消息</h6><pre><code><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/streadway/amqp"</span></span><br><span class="line"><span class="comment">// step 1. 创建 connection</span></span><br><span class="line">conn, err := amqp.Dial(<span class="string">"amqp://guest:guest@127.0.0.1:5672/"</span>)</span><br><span class="line"><span class="comment">// step 2. 获取 (信道)channel</span></span><br><span class="line">channel, err := conn.Channel()</span><br><span class="line"><span class="comment">// step 3. 在信道上声明交换器 exchange</span></span><br><span class="line">channel.ExchangeDeclare(</span><br><span class="line">    <span class="string">"exchange_name"</span>,     <span class="comment">// exchange name</span></span><br><span class="line">    amqp.ExchangeDirect, <span class="comment">// exchange type</span></span><br><span class="line">    <span class="literal">false</span>,               <span class="comment">// durable</span></span><br><span class="line">    <span class="literal">false</span>,               <span class="comment">// autoDelete</span></span><br><span class="line">    <span class="literal">false</span>,               <span class="comment">// internal</span></span><br><span class="line">    <span class="literal">false</span>,               <span class="comment">// noWait</span></span><br><span class="line">    <span class="literal">nil</span>,                 <span class="comment">// args amqp.Table</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// step 4. 声明队列</span></span><br><span class="line">queue, err := ch.QueueDeclare(</span><br><span class="line">        <span class="string">"queue_name"</span>,    <span class="comment">// queue name</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// durable</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// delete when unused</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// exclusive</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// no-wait</span></span><br><span class="line">        <span class="literal">nil</span>,             <span class="comment">// arguments amqp.Table</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// step 5. 将队列绑定根据路由键绑定到交换器上</span></span><br><span class="line">channel.QueueBind(</span><br><span class="line">    queue.Name,          <span class="comment">// queue name</span></span><br><span class="line">    <span class="string">"route_key"</span>,         <span class="comment">// route key</span></span><br><span class="line">    <span class="string">"exchange_name"</span>,     <span class="comment">// exchange name</span></span><br><span class="line">    <span class="literal">false</span>,               <span class="comment">// no-wait</span></span><br><span class="line">    <span class="literal">nil</span>,                 <span class="comment">// arguments amqp.Table</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// step 6. 将消息发送到交换器上，交换器会根据路由键将消息发送到对应的队列queue</span></span><br><span class="line">channel.Publish(</span><br><span class="line">        <span class="string">"exchange_name"</span>, <span class="comment">// exchange</span></span><br><span class="line">        <span class="string">"route_key"</span>,     <span class="comment">// routing key</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// mandatory</span></span><br><span class="line">        <span class="literal">false</span>,           <span class="comment">// immediate</span></span><br><span class="line">        amqp.Publishing&#123; <span class="comment">// message</span></span><br><span class="line">            ContentType: <span class="string">"text/plain"</span>,</span><br><span class="line">            Body:        []<span class="keyword">byte</span>(<span class="string">"hello world"</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="消费者订阅消息"><a href="#消费者订阅消息" class="headerlink" title="消费者订阅消息"></a>消费者订阅消息</h6><pre><code><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">import</span> <span class="string">"github.com/streadway/amqp"</span></span><br><span class="line">   <span class="comment">// step 1. 创建 connection</span></span><br><span class="line">   conn, err := amqp.Dial(<span class="string">"amqp://guest:guest@127.0.0.1:5672/"</span>)</span><br><span class="line">   <span class="comment">// step 2. 获取 (信道)channel</span></span><br><span class="line">   channel, err := conn.Channel()</span><br><span class="line">   <span class="comment">// step 3. 在信道上声明交换器 exchange</span></span><br><span class="line">   channel.ExchangeDeclare(</span><br><span class="line">       <span class="string">"exchange_name"</span>,     <span class="comment">// exchange name</span></span><br><span class="line">       amqp.ExchangeDirect, <span class="comment">// exchange type</span></span><br><span class="line">       <span class="literal">false</span>,               <span class="comment">// durable</span></span><br><span class="line">       <span class="literal">false</span>,               <span class="comment">// autoDelete</span></span><br><span class="line">       <span class="literal">false</span>,               <span class="comment">// internal</span></span><br><span class="line">       <span class="literal">false</span>,               <span class="comment">// noWait</span></span><br><span class="line">       <span class="literal">nil</span>,                 <span class="comment">// args amqp.Table</span></span><br><span class="line">   )</span><br><span class="line">   <span class="comment">// step 4. 声明队列</span></span><br><span class="line">   queue, err := ch.QueueDeclare(</span><br><span class="line">           <span class="string">"queue_name"</span>,    <span class="comment">// queue name</span></span><br><span class="line">           <span class="literal">false</span>,           <span class="comment">// durable</span></span><br><span class="line">           <span class="literal">false</span>,           <span class="comment">// delete when unused</span></span><br><span class="line">           <span class="literal">false</span>,           <span class="comment">// exclusive</span></span><br><span class="line">           <span class="literal">false</span>,           <span class="comment">// no-wait</span></span><br><span class="line">           <span class="literal">nil</span>,             <span class="comment">// arguments amqp.Table</span></span><br><span class="line">   )</span><br><span class="line">   <span class="comment">// step 5. 将队列绑定根据路由键绑定到交换器上</span></span><br><span class="line">   channel.QueueBind(</span><br><span class="line">       queue.Name,          <span class="comment">// queue name</span></span><br><span class="line">       <span class="string">"route_key"</span>,         <span class="comment">// route key</span></span><br><span class="line">       <span class="string">"exchange_name"</span>,     <span class="comment">// exchange name</span></span><br><span class="line">       <span class="literal">false</span>,               <span class="comment">// no-wait</span></span><br><span class="line">       <span class="literal">nil</span>,                 <span class="comment">// arguments amqp.Table</span></span><br><span class="line">   )</span><br><span class="line">   forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">   <span class="comment">// step 6. 在信道上订阅队列</span></span><br><span class="line">   messages, err := channel.Consume(</span><br><span class="line">       queue.Name,           <span class="comment">// queue</span></span><br><span class="line">       <span class="string">""</span>,                   <span class="comment">// consumer</span></span><br><span class="line">       <span class="literal">false</span>,                <span class="comment">// autoAck</span></span><br><span class="line">       <span class="literal">false</span>,                <span class="comment">// exclusive</span></span><br><span class="line">       <span class="literal">false</span>,                <span class="comment">// noLocal ：The noLocal flag is not supported by RabbitMQ.</span></span><br><span class="line">       <span class="literal">false</span>,                <span class="comment">// no-wait</span></span><br><span class="line">       <span class="literal">nil</span>,                  <span class="comment">// arguments amqp.Table</span></span><br><span class="line">   )</span><br><span class="line">  <span class="comment">// 开启一个 goruntine 获取消息内容 </span></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> message := <span class="keyword">range</span> messages &#123;</span><br><span class="line">               log.Printf(<span class="string">"Received a message: %s"</span>, message.Body)</span><br><span class="line">               message.Ack(<span class="literal">true</span>)</span><br><span class="line">       &#125;</span><br><span class="line">&#125;()</span><br><span class="line">   fmt.Println(<span class="string">"Please ctrl+c to stop"</span>)</span><br><span class="line">   &lt;-forever</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      
        <categories>
            
            <category> mq </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rabbitmq queue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开启https小绿锁 let's encrypt]]></title>
      <url>/2018/01/02/let-s-encrypt/</url>
      <content type="html"><![CDATA[<p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<h6 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title="Let’s Encrypt"></a>Let’s Encrypt</h6><p>Let’s Encrypt是2016年4月12日成立的一家证书授权中心，提供免费的传输层安全（TLS）X.509证书，通过自动化的过程消除目前安全网站证书需要手工创建，加密，签名，安装以及更新的复杂性。</p>
<h6 id="获取-let’s-encrypt"><a href="#获取-let’s-encrypt" class="headerlink" title="获取 let’s encrypt"></a>获取 let’s encrypt</h6><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/certbot/certbot.git</span><br></pre></td></tr></table></figure>
</code></pre><h6 id="安装ssl证书"><a href="#安装ssl证书" class="headerlink" title="安装ssl证书"></a>安装ssl证书</h6><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./certbot-auto certonly --standalone -d example.com --email example@email.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># certbot-auto renew  重新安装之前存在的ssl证书</span></span><br></pre></td></tr></table></figure>
</code></pre><h6 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h6><pre><code><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/example.com/cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/example.com/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#双向 ssl 认证</span></span><br><span class="line">    <span class="comment"># ssl_verify_client on;</span></span><br><span class="line">    <span class="comment"># ssl_client_certificate /etc/letsencrypt/live/example.com/cert.pem;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> https </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你好，世界]]></title>
      <url>/2018/01/01/hello-world/</url>
      <content type="html"><![CDATA[<pre><code><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">我一直以为悲伤是一种美丽，一种壮丽，</span><br><span class="line">这世界让我如此失望，</span><br><span class="line">我经不起这风吹雨打的折磨，</span><br><span class="line">我寻找的结局，</span><br><span class="line">我追寻的是哭里的笑声，</span><br><span class="line">默默地完成生命的剩余</span><br></pre></td></tr></table></figure>
</code></pre>]]></content>
      
        
    </entry>
    
  
  
</search>
